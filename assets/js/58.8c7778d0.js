(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{484:function(e,a,t){"use strict";t.r(a);var s=t(0),v=Object(s.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("blockquote",[a("p",[e._v("管理工具下载地址：https://redisdesktop.com/download\n安装：https://www.jianshu.com/p/ebda253a8daa")])]),e._v(" "),a("h2",{attrs:{id:"centos安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#centos安装"}},[e._v("#")]),e._v(" centos安装")]),e._v(" "),a("blockquote",[a("p",[e._v("参考：https://www.jianshu.com/p/ebda253a8daa")])]),e._v(" "),a("h3",{attrs:{id:"方式一"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式一"}},[e._v("#")]),e._v(" 方式一：")]),e._v(" "),a("ol",[a("li",[e._v("切换到阿里源\n"),a("code",[e._v("mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup")]),e._v(" "),a("code",[e._v("wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo")])]),e._v(" "),a("li",[e._v("安装启动\n"),a("code",[e._v("yum install redis")]),e._v(" "),a("code",[e._v("systemctl start redis.service")]),e._v(" "),a("code",[e._v("systemctl enable redis.service")])]),e._v(" "),a("li",[e._v("修改配置\n"),a("blockquote",[a("p",[e._v("配置文件位置："),a("code",[e._v("/etc/redis.conf")]),e._v("\n参考：http://yijiebuyi.com/blog/bc2b3d3e010bf87ba55267f95ab3aa71.html")])])])]),e._v(" "),a("h3",{attrs:{id:"方式二"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方式二"}},[e._v("#")]),e._v(" 方式二：")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("通过docker安装\n"),a("code",[e._v("docker pull redis")])])]),e._v(" "),a("li",[a("p",[e._v("下载redis的配置文件（redis.conf）")]),e._v(" "),a("blockquote",[a("p",[e._v("https://github.com/antirez/redis")])])]),e._v(" "),a("li",[a("p",[e._v("启动容器\n"),a("code",[e._v("docker run --name redis -d -p6379:6379 -v /data/docker/redis/redis.conf:/usr/local/etc/redis/redis.conf redis redis-server /usr/local/etc/redis/redis.conf")])])])]),e._v(" "),a("h2",{attrs:{id:"rdb备份"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#rdb备份"}},[e._v("#")]),e._v(" RDB备份")]),e._v(" "),a("blockquote",[a("p",[e._v("参考：http://redisdoc.com/topic/persistence.html\nRDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。")])]),e._v(" "),a("h3",{attrs:{id:"优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),a("ol",[a("li",[e._v("RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份： 比如说，你可以在最近的 24 小时内，每小时备份一次 RDB 文件，并且在每个月的每一天，也备份一个 RDB 文件。 这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。")]),e._v(" "),a("li",[e._v("RDB 非常适用于灾难恢复（disaster recovery）：它只有一个文件，并且内容都非常紧凑，可以（在加密后）将它传送到别的数据中心，或者亚马逊 S3 中。")]),e._v(" "),a("li",[e._v("RDB 可以最大化 Redis 的性能：父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作。")]),e._v(" "),a("li",[e._v("RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。")])]),e._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),a("ol",[a("li",[e._v("如果你需要尽量避免在服务器故障时丢失数据，那么 RDB 不适合你。 虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。")]),e._v(" "),a("li",[e._v("每次保存 RDB 的时候，Redis 都要 fork() 出一个子进程，并由子进程来进行实际的持久化工作。 在数据集比较庞大时， fork() 可能会非常耗时，造成服务器在某某毫秒内停止处理客户端； 如果数据集非常巨大，并且 CPU 时间非常紧张的话，那么这种停止时间甚至可能会长达整整一秒。 虽然 AOF 重写也需要进行 fork() ，但无论 AOF 重写的执行间隔有多长，数据的耐久性都不会有任何损失。")])]),e._v(" "),a("h3",{attrs:{id:"配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置"}},[e._v("#")]),e._v(" 配置")]),e._v(" "),a("ol",[a("li",[e._v("修改配置（默认开启）")])]),e._v(" "),a("p",[a("img",{attrs:{src:"http://image.xuguoliang.top/1515742228655.jpg",alt:"备份策略"}})]),e._v(" "),a("p",[e._v("禁用，就"),a("code",[e._v('save ""')]),e._v("，符合策略的操作会自动备份到dump.rdb文件中")]),e._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[e._v("写定时器发送的远程服务器，备份。")]),e._v(" "),a("li",[e._v("关闭redis服务替换备份的文件，重启。")])]),e._v(" "),a("blockquote",[a("p",[e._v("可能会丢失最后一次时间段数据，对于大规模数据备份比较好。")])]),e._v(" "),a("h2",{attrs:{id:"aof备份"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#aof备份"}},[e._v("#")]),e._v(" AOF备份")]),e._v(" "),a("blockquote",[a("p",[e._v("参考：http://redisdoc.com/topic/persistence.html")])]),e._v(" "),a("blockquote",[a("p",[e._v("AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。")])]),e._v(" "),a("blockquote",[a("p",[e._v("Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 "),a("strong",[e._v("在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。")])])]),e._v(" "),a("h3",{attrs:{id:"优点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-2"}},[e._v("#")]),e._v(" 优点")]),e._v(" "),a("ol",[a("li",[e._v("使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。")]),e._v(" "),a("li",[e._v("AOF 文件是一个只进行追加操作的日志文件（append only log）， 因此对 AOF 文件的写入不需要进行 seek ， 即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等）， redis-check-aof 工具也可以轻易地修复这种问题。")]),e._v(" "),a("li",[e._v("Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。")]),e._v(" "),a("li",[e._v("AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松。 导出（export） AOF 文件也非常简单： 举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写， 那么只要停止服务器， 移除 AOF 文件末尾的 FLUSHALL 命令， 并重启 Redis ， 就可以将数据集恢复到 FLUSHALL 执行之前的状态。")])]),e._v(" "),a("h3",{attrs:{id:"缺点-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-2"}},[e._v("#")]),e._v(" 缺点")]),e._v(" "),a("ol",[a("li",[e._v("对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。")]),e._v(" "),a("li",[e._v("根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。")]),e._v(" "),a("li",[e._v("AOF 在过去曾经发生过这样的 bug ： 因为个别命令的原因，导致 AOF 文件在重新载入时，无法将数据集恢复成保存时的原样。 （举个例子，阻塞命令 BRPOPLPUSH 就曾经引起过这样的 bug 。） 测试套件里为这种情况添加了测试： 它们会自动生成随机的、复杂的数据集， 并通过重新载入这些数据来确保一切正常。 虽然这种 bug 在 AOF 文件中并不常见， 但是对比来说， RDB 几乎是不可能出现这种 bug 的。")])]),e._v(" "),a("h3",{attrs:{id:"配置-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#配置-2"}},[e._v("#")]),e._v(" 配置")]),e._v(" "),a("blockquote",[a("p",[e._v("AOF保存的是appendonly.aof文件")])]),e._v(" "),a("p",[a("img",{attrs:{src:"http://image.xuguoliang.top/1516111774389.jpg",alt:"开启配置"}})]),e._v(" "),a("p",[a("img",{attrs:{src:"http://image.xuguoliang.top/1516111831791.jpg",alt:""}})]),e._v(" "),a("ul",[a("li",[e._v("每修改同步：appendfsync always   同步持久化 每次发生数据变更会被立即记录到磁盘  性能较差但数据完整性比较好")]),e._v(" "),a("li",[e._v("每秒同步：appendfsync everysec    异步操作，每秒记录   如果一秒内宕机，有数据丢失")]),e._v(" "),a("li",[e._v("完全依赖OS的写入，一般为30秒左右一次，性能最好但是持久化最没有保证，不被推荐。")])]),e._v(" "),a("blockquote",[a("p",[e._v("文件位置 /var/lib/redis/appendonly.aof")])]),e._v(" "),a("h3",{attrs:{id:"检查appendonly-aof文件是否完整"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查appendonly-aof文件是否完整"}},[e._v("#")]),e._v(" 检查appendonly.aof文件是否完整")]),e._v(" "),a("p",[a("code",[e._v("/usr/bin/redis-check-aof --fix appendonly.aof")]),e._v(" "),a("code",[e._v("redis-check-aof --fix")]),e._v(" 检查文件")]),e._v(" "),a("blockquote",[a("p",[e._v("默认文件超过64M就自动压缩。")])]),e._v(" "),a("h3",{attrs:{id:"问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题"}},[e._v("#")]),e._v(" 问题")]),e._v(" "),a("ol",[a("li",[e._v("在恢复appendonly.aof后，redis无法启动。\n发现是文件的权限不对。修改权限即可。\n"),a("code",[e._v("chown redis appendonly.aof")])])]),e._v(" "),a("h2",{attrs:{id:"主从"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从"}},[e._v("#")]),e._v(" 主从")]),e._v(" "),a("h3",{attrs:{id:"作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[e._v("#")]),e._v(" 作用")]),e._v(" "),a("ul",[a("li",[e._v("主从复制")]),e._v(" "),a("li",[e._v("读写分离")])]),e._v(" "),a("h3",{attrs:{id:"修改配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#修改配置"}},[e._v("#")]),e._v(" 修改配置")]),e._v(" "),a("p",[e._v("复制redis.conf，并修改\n"),a("code",[e._v("daemonize yes")]),e._v(" "),a("code",[e._v("port 6379")]),e._v(" "),a("code",[e._v("pidfile /var/run/redis_6379.pid")]),e._v(" "),a("code",[e._v("logfile /var/log/redis/redis6379.log")]),e._v(" "),a("code",[e._v("dbfilename dump.rdb")]),e._v(" "),a("code",[e._v('appendfilename "appendonly.aof"')])]),e._v(" "),a("h3",{attrs:{id:"常用方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用方式"}},[e._v("#")]),e._v(" 常用方式")]),e._v(" "),a("h4",{attrs:{id:"一主二仆"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一主二仆"}},[e._v("#")]),e._v(" 一主二仆")]),e._v(" "),a("blockquote",[a("p",[e._v("从库只能读，不能写。")])]),e._v(" "),a("p",[e._v("配置主从\n"),a("code",[e._v("slaveof ip port")]),e._v("   slaveof 127.0.0.1 6379\n查询从库状态\n"),a("code",[e._v("info replication")])]),e._v(" "),a("p",[a("img",{attrs:{src:"http://image.xuguoliang.top/1516268405021.jpg",alt:"连接失败"}})]),e._v(" "),a("blockquote",[a("p",[a("code",[e._v("master_link_status:down")]),e._v("\n链接失败\n原因分析：查看日志后，发现没有配置密码\n参考：http://yaycici.blog.163.com/blog/static/173759063201682725830308/")])]),e._v(" "),a("p",[e._v("查看主库状态")]),e._v(" "),a("p",[a("img",{attrs:{src:"http://image.xuguoliang.top/1516272844992.jpg",alt:"主库状态"}})]),e._v(" "),a("h3",{attrs:{id:"薪火相传"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#薪火相传"}},[e._v("#")]),e._v(" 薪火相传")]),e._v(" "),a("p",[e._v("上一个Slave可以是下一个slave的Master，Slave同样可以接收其他\nslaves的连接和同步请求，那么该slave作为了链条中下一个的master,\n可以有效减轻master的写压力")]),e._v(" "),a("h4",{attrs:{id:"反客为主"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反客为主"}},[e._v("#")]),e._v(" 反客为主")]),e._v(" "),a("p",[a("code",[e._v("SLAVEOF no one")]),e._v("\n使当前数据库停止与其他数据库的同步，转成主数据库")]),e._v(" "),a("h3",{attrs:{id:"复制原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#复制原理"}},[e._v("#")]),e._v(" 复制原理")]),e._v(" "),a("p",[e._v("Slave启动成功连接到master后会发送一个sync命令\nMaster接到命令启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令， 在后台进程执行完毕之后，master将传送整个数据文件到slave,以完成一次完全同步\n全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。\n增量复制：Master继续将新的所有收集到的修改命令依次传给slave,完成同步\n但是只要是重新连接master,一次完全同步（全量复制)将被自动执行")]),e._v(" "),a("h3",{attrs:{id:"哨兵模式-sentinel"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式-sentinel"}},[e._v("#")]),e._v(" 哨兵模式(sentinel)")]),e._v(" "),a("p",[e._v("反客为主的自动版，能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库")])])}),[],!1,null,null,null);a.default=v.exports}}]);