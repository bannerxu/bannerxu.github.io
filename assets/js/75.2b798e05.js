(window.webpackJsonp=window.webpackJsonp||[]).push([[75],{502:function(e,a,v){"use strict";v.r(a);var r=v(0),s=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"介绍"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[e._v("#")]),e._v(" 介绍")]),e._v(" "),a("p",[e._v("Docker可以通过阅读Docker的指令来自动构建映像 Dockerfile。A Dockerfile是一个文本文档，\n其中包含用户可以在命令行上调用以组装图像的所有命令。使用docker build 用户可以创建一个自动构建，\n该构建连续执行多个命令行指令。")]),e._v(" "),a("h2",{attrs:{id:"基础知识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础知识"}},[e._v("#")]),e._v(" 基础知识")]),e._v(" "),a("ul",[a("li",[e._v("每条保留字指令都必须为大写字母且后面要跟随至少一个参数")]),e._v(" "),a("li",[e._v("指令按照从上到下，顺序执行")]),e._v(" "),a("li",[a("code",[e._v("#")]),e._v("表示注释")]),e._v(" "),a("li",[e._v("每条指令都会创建一个新的镜像层，并对镜像进行提交")])]),e._v(" "),a("h2",{attrs:{id:"重点-指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重点-指令"}},[e._v("#")]),e._v(" 重点：指令")]),e._v(" "),a("h3",{attrs:{id:"from"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#from"}},[e._v("#")]),e._v(" FROM")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("FROM <image>")]),e._v("或"),a("code",[e._v("FROM <image>:<tag>")]),e._v("。")]),e._v(" "),a("p",[e._v("第一条指令必须为 "),a("code",[e._v("FROM")]),e._v(" 指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个 "),a("code",[e._v("FROM")]),e._v(" 指令（每个镜像一次）")]),e._v(" "),a("h3",{attrs:{id:"maintainer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#maintainer"}},[e._v("#")]),e._v(" MAINTAINER")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("MAINTAINER <name>")]),e._v("，指定维护者信息。")]),e._v(" "),a("h3",{attrs:{id:"run"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#run"}},[e._v("#")]),e._v(" RUN")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("RUN <command>")]),e._v(" 或 "),a("code",[e._v('RUN ["executable", "param1", "param2"]')]),e._v("。\n前者将在 shell 终端中运行命令，即 "),a("code",[e._v("/bin/sh -c")]),e._v("；后者则使用 "),a("code",[e._v("exec")]),e._v(" 执行。指定使用其它终端可以通过第二种方式实现，例如 "),a("code",[e._v('RUN ["/bin/bash", "-c", "echo hello"]')]),e._v("。\n每条 "),a("code",[e._v("RUN")]),e._v(" 指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时可以使用 "),a("code",[e._v("\\")]),e._v(" 来换行。")]),e._v(" "),a("h3",{attrs:{id:"cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[e._v("#")]),e._v(" CMD")]),e._v(" "),a("p",[e._v("支持三种格式")]),e._v(" "),a("ul",[a("li",[a("code",[e._v('CMD ["executable","param1","param2"]')]),e._v(" 使用 "),a("code",[e._v("exec")]),e._v(" 执行，推荐方式；")]),e._v(" "),a("li",[a("code",[e._v("CMD command param1 param2")]),e._v(" 在 "),a("code",[e._v("/bin/sh")]),e._v(" 中执行，提供给需要交互的应用；")]),e._v(" "),a("li",[a("code",[e._v('CMD ["param1","param2"]')]),e._v(" 提供给 "),a("code",[e._v("ENTRYPOINT")]),e._v(" 的默认参数；")])]),e._v(" "),a("p",[a("strong",[e._v("指定启动容器时执行的命令，每个 Dockerfile 只能有一条 "),a("code",[e._v("CMD")]),e._v(" 命令。如果指定了多条命令，只有最后一条会被执行。")]),e._v(" "),a("strong",[e._v("如果用户启动容器时候指定了运行的命令，则会覆盖掉 "),a("code",[e._v("CMD")]),e._v(" 指定的命令。")])]),e._v(" "),a("h3",{attrs:{id:"expose"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expose"}},[e._v("#")]),e._v(" EXPOSE")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("EXPOSE <port> [<port>...]")]),e._v("。\n告诉 Docker 服务端容器暴露的端口号，供互联系统使用。在启动容器时需要通过 -P，Docker 主机会自动分配一个端口转发到指定的端口。")]),e._v(" "),a("h3",{attrs:{id:"env"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#env"}},[e._v("#")]),e._v(" ENV")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("ENV <key> <value>")]),e._v("。 指定一个环境变量，会被后续 "),a("code",[e._v("RUN")]),e._v(" 指令使用，并在容器运行时保持。")]),e._v(" "),a("h3",{attrs:{id:"add"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#add"}},[e._v("#")]),e._v(" ADD")]),e._v(" "),a("p",[e._v("格式为"),a("code",[e._v("ADD <src> <dest>")]),e._v("。\n该命令将复制指定的"),a("code",[e._v("<src>")]),e._v("到容器中的 "),a("code",[e._v("<dest>")]),e._v("。 其中 "),a("code",[e._v("<src>")]),e._v("可以是Dockerfile所在目录的一个相对路径；也可以是一个 URL；还可以是一个 tar 文件（自动解压为目录）。")]),e._v(" "),a("h3",{attrs:{id:"copy"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#copy"}},[e._v("#")]),e._v(" COPY")]),e._v(" "),a("p",[e._v("格式为"),a("code",[e._v("COPY <src> <dest>")]),e._v("。\n复制本地主机的 "),a("code",[e._v("<src>")]),e._v("（为 Dockerfile 所在目录的相对路径）到容器中的 "),a("code",[e._v("<dest>")]),e._v("。\n当使用本地目录为源目录时，推荐使用 "),a("code",[e._v("COPY")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"entrypoint"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#entrypoint"}},[e._v("#")]),e._v(" ENTRYPOINT")]),e._v(" "),a("p",[e._v("两种格式：")]),e._v(" "),a("ul",[a("li",[a("code",[e._v('ENTRYPOINT ["executable", "param1", "param2"]')])]),e._v(" "),a("li",[a("code",[e._v("ENTRYPOINT command param1 param2")]),e._v("（shell中执行）。")])]),e._v(" "),a("p",[e._v("配置容器启动后执行的命令，并且不可被 docker run 提供的参数覆盖。\n"),a("strong",[e._v("每个 Dockerfile 中只能有一个 "),a("code",[e._v("ENTRYPOINT")]),e._v("，当指定多个时，只有最后一个起效。")])]),e._v(" "),a("h3",{attrs:{id:"volume"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#volume"}},[e._v("#")]),e._v(" VOLUME")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v('VOLUME ["/data"]')]),e._v("。\n创建一个可以从本地主机或其他容器挂载的挂载点，一般用来存放数据库和需要保持的数据等。")]),e._v(" "),a("h3",{attrs:{id:"user"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user"}},[e._v("#")]),e._v(" USER")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("USER daemon")]),e._v("。\n指定运行容器时的用户名或 UID，后续的 "),a("code",[e._v("RUN")]),e._v(" 也会使用指定用户。\n当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户，例如："),a("code",[e._v("RUN groupadd -r postgres && useradd -r -g postgres postgres")]),e._v("。要临时获取管理员权限可以使用 "),a("code",[e._v("gosu")]),e._v("，而不推荐 "),a("code",[e._v("sudo")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"workdir"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#workdir"}},[e._v("#")]),e._v(" WORKDIR")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("WORKDIR /path/to/workdir")]),e._v("。\n为后续的 "),a("code",[e._v("RUN")]),e._v("、"),a("code",[e._v("CMD")]),e._v("、"),a("code",[e._v("ENTRYPOINT")]),e._v(" 指令配置工作目录。\n可以使用多个 "),a("code",[e._v("WORKDIR")]),e._v(" 指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。例如")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("WORKDIR /a\nWORKDIR b\nWORKDIR c\nRUN pwd\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br")])]),a("p",[e._v("则最终路径为 /a/b/c。")]),e._v(" "),a("h3",{attrs:{id:"onbuild"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#onbuild"}},[e._v("#")]),e._v(" ONBUILD")]),e._v(" "),a("p",[e._v("格式为 "),a("code",[e._v("ONBUILD [INSTRUCTION]")]),e._v("。")]),e._v(" "),a("p",[e._v("配置当所创建的镜像作为其它新创建镜像的基础镜像时，所执行的操作指令。")]),e._v(" "),a("p",[e._v("例如，Dockerfile 使用如下的内容创建了镜像 image-A。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ONBUILD ADD . /app/src\nONBUILD RUN /usr/local/bin/python-build --dir /app/src\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br")])]),a("p",[e._v("如果基于 image-A 创建新的镜像时，新的Dockerfile中使用 "),a("code",[e._v("FROM image-A")]),e._v("指定基础镜像时，会自动执行 "),a("code",[e._v("ONBUILD")]),e._v(" 指令内容，等价于在后面添加了两条指令。")]),e._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("FROM image-A\n\n#Automatically run the following\nADD . /app/src\nRUN /usr/local/bin/python-build --dir /app/src\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("使用 "),a("code",[e._v("ONBUILD")]),e._v(" 指令的镜像，推荐在标签中注明，例如 "),a("code",[e._v("ruby:1.9-onbuild")]),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构建"}},[e._v("#")]),e._v(" 构建")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://docs.docker.com/engine/reference/commandline/build/",target:"_blank",rel:"noopener noreferrer"}},[e._v("官网"),a("OutboundLink")],1)]),e._v(" "),a("div",{staticClass:"language-shell line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-shell"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[e._v("docker")]),e._v(" build "),a("span",{pre:!0,attrs:{class:"token parameter variable"}},[e._v("-t")]),e._v(" 新镜像名字:TAG "),a("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v(".")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br")])]),a("p",[e._v("也可以通过 "),a("code",[e._v(".dockerignore")]),e._v(" 文件（每一行添加一条匹配模式）来让 Docker 忽略路径下的目录和文件。")])])}),[],!1,null,null,null);a.default=s.exports}}]);